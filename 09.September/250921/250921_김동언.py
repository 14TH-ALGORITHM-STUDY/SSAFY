'''
마을에 N개의 집과 M개의 길이 있다. 각 길은 유지비가 있다.
마을을 2개의 마을로 분할한다. (각 마을에 집이 하나 이상 있어야한다.)
각 마을의 임의의 집은 항상 다른 임의의 집과 연결되어 있다.
위의 조건을 만족하고 유지비가 최소가 되는 경우를 만들 때의 유지비는 얼마인가?
'''

# 입력 처리 속도 최적화
# 계속 시간초과돼서 30분 동안 최적화한다고 난리 쳤는데 이거 두 줄 넣으니까 바로 pass 나오네...
import sys
input = sys.stdin.readline

# h1집과 h2집을 연결한다. 만약 이미 다른 집을 통해서 연결되어있다면 pass
def union(h1, h2):
    # h1집과 h2집의 대표를 찾는다
    h1 = find_set(h1)
    h2 = find_set(h2)

    # 각 집의 대표가 같다는 것은 이미 두 집은 알게모르게 연결되어있다는 것 = 굳이 두 집을 연결할 필요가 없다.
    if h1 == h2:
        # 나중에 연결했는지 안했는지 구분하기위해 연결하지 않으면 0을 반환한다.
        return 0
    
    # 각 집의 대표가 다르다면 두 집은 연결되지 않았음. 그럼 연결시켜준다.
    else:
        # rank가 더 큰 집에 작은 집을 붙인다.
        # 시간 효율을 위해서!
        if rank[h1] > rank[h2]:
            boss[h2] = h1
            rank[h1] = max(rank[h1], (rank[h2] + 1))
        else:
            boss[h1] = h2
            rank[h2] = max(rank[h2], (rank[h1] + 1))
        
        # 나중에 연결했는지 안했는지 구분하기위해 연결했으면 1을 반환한다.
        return 1

# house가 연결되어있는 집 중 대표를 찾는다.
def find_set(house):
    # 현재 등록되어있는 자기 집의 대표가 본인이 아니라면 계속 위로 올라가면서 찐 대표를 찾는다.
    if boss[house] != house:
        # 함수를 실행 할 때마다 연결된 모든 집을 하나하나 타고 올라가면서 찐대표를 찾으려면 시간이 오래 걸린다.
        # 그래서 찐 대표가 누군지 찾았으면 해당 경로에 있는 모든 집을 맞선임을 가리키는 것이 아닌 바로 찐 대표를 가리키도록 수정한다.
        boss[house] = find_set(boss[house])
        
    return boss[house]

# n : 마을의 수, m : 길의 수
n, m = map(int, input().split())

# 집을 연결하는 길에대한 input정보를 저장할 리스트 
road_list = []

for _ in range(m):
    # a: 길로 연결된 첫번째 집, b: 길로 연결된 두번째 집, c: a집과 b집 사이에 있는 길의 유지비
    a, b, c = map(int, input().split())

    # road_list라는 리스트에 길 정보를 넣음. 오름차순으로 정렬하기 위해 c를 가장 앞에 위치시킴
    road_list.append((c, a, b))

# 오름차순 정렬
road_list.sort()

# boss 리스트의 인덱스 : 집의 번호
# boss 리스트의 값 : 인덱스에 해당하는 집의 대표 집
# 3번 인덱스의 값이 6이다 : 3번 집의 대표는 6번 집이다.
# 집의 번호랑 인덱스를 맞춰주기위해서 n+1까지 생성
boss = [house for house in range(n+1)]

# 각 집의 랭크(자신을 루트로 하는 sub트리의 높이를 표시)
rank = [0] * (n+1)

#최소비용을 저장할 변수 / 최종적으로 출력할 값
min_cost = 0

# n개의 집이 있으니 모든 집을 연결시키기 위해 필요한 길의 수의 최소값은 n-1개이다.
# 그러나 두 개의 마을로 나누어야하니 n-2개의 길을 선택해서 두 개의 마을로 나누어지게 할 것이다.
# n-1개의 길을 연결해야 모든 집이 연결되는데 그보다 길 하나를 줄인다면 모두 연결되지 못하고 총 두 개의 집단으로 나누어질 것
# n-2개의 길을 선택하기위해서 길을 선택할 때마다 1씩 더해줄 cnt 변수
cnt = 0

for cost, h1, h2 in road_list:
    
    # n개의 집을 연결하기 위해 필요한 길의 최소 개수는 n-1개이다.
    # 그러나 마을을 2개로 나누어야하니 길을 하나 덜 연결시켜주어야한다. 그래서 n-2개의 길을 선택하면 멈춘다.
    if cnt == n-2:
        break
    
    # h1집과 h2집을 연결시킨다.
    #union(h1, h2)의 return 값이 0이다 : 두 집은 이미 연결되어 있으니 연결할 필요가 없다.
    #union(h1, h2)의 return 값이 1이다 : 두 집은 연결되어있지 않으니 연결해야한다.
    if union(h1, h2) == 1:
        min_cost += cost
        cnt += 1


print(min_cost)