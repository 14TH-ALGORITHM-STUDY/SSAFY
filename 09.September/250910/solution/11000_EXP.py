'''
-문제 요약
여러 개의 수업들의 시작 시간과 종료 시간이 주어졌을 때, 모든 수업을 진행하기 위해 필요한 최소한의 강의실 개수를 구하는 문제.
한 강의실에서는 동시에 두 개 이상의 수업을 진행할 수 없습니다.

-문제 조건 분석
시간 제한 : 1초 (일반적으로 Python으로는 약 1억 번의 연산이 가능하다.)
입력값 범위 : 수업의 개수 N이 최대 200,000

시간복잡도가 n^2인 알고리즘 사용시 연산횟수는 200,000^2 = 400억번, 1초안에 불가능
그래서 시간복잡도가 nlogn인 알고리즘을 사용해야한다.

-풀이방법
사용할 방식 : 우선순위 큐
구현에 사용할 자료구조 : heap

일반적인 큐 : 선입 선출(FIFO)
우선순위 큐 : 순서와 상관없이 우선순위가 높은 순서대로 pop, (EX 최댓값, 최솟값, 길이가 긴 순서 등)

heap: 최댓값과, 최솟값을 빠르게 출력할 수 있는 완전이진트리 형식의 자료구조
최소힙 : 부모 노드의 값이 항상 자식 노드의 값보다 작거나 같은 힙, 루트(가장 상위)노드에는 항상 전체 원소 중 최솟값이 위치

-참고자료
heap 관련 자료1 : https://blog.naver.com/baseball3724/223647815561
heap 관련 자료2 : https://velog.io/@kjhxxxx/Python-힙-Heap
import 없이 heap 구현 : https://haegomm.tistory.com/entry/python-힙heap과-힙큐heapq란

c++에서는 std::priority_queue 사용, 기본값이 최대 힙으로 동작 
'''

import heapq

'''
설명용 input:
7
6 10
3 5
4 9
2 4
1 3
5 11
8 12
'''

n = int(input()) #수업의 개수

time_list = [list(map(int, input().split())) for _ in range(n)] #수업시작, 종료시간을 리스트에 저장
print(time_list) # [[6, 10], [3, 5], [4, 9], [2, 4], [1, 3], [5, 11], [8, 12]]

time_list.sort() #시작시간을 기준으로 오름차순으로 정렬
print(time_list) #[[1, 3], [2, 4], [3, 5], [4, 9], [5, 11], [6, 10], [8, 12]]
#종료시간이 아닌 시작시간을 기준으로 정렬하는 이유 : 현재 확인 중인 강의보다 더 일찍 시작하는 강의가 없다는 것을 보장할 수 있다.

rooms = [] #rooms에 있는 각 요소는 해당 강의실의 수업이 끝나는 시간 (최종적으로 rooms의 요소의 수량이 필요한 강의실의 수량)
#EX) rooms = [3, 5, 7, 8] 라고한다면, 강의실이 총 4개가 필요하고 1번 강의실의 수업이 끝나는 시간: 3, 2번 강의실의 수업이 끝나는 시간: 5, 3번 강의실의 수업이 끝나는 시간: 7, 4번 강의실의 수업이 끝나는 시간: 8
#시작시간이 아닌 종료시간을 추가하는 이유 : 새로운 강의를 배정하기위해선 이전 수업의 끝나는 시간이 중요하므로

heapq.heappush(rooms, time_list[0][1]) #가장 첫강의는 가능여부 확인할 필요 없으니 바로 추가(수업 종료시간이 추가됨)
print(rooms) #[3]

for i in range(1, n): #바로 위에서 0번째는 추가했으니 1번 인덱스부터 범위 조절)
    if time_list[i][0] >= rooms[0]: #i번째 수업의 시작시간이 rooms의 0번째 인덱스 보다 뒤인지 확인(rooms의 0번째 인덱스 : rooms안에 있는 가장 빠른 종료시간)
        heapq.heappop(rooms) #기존 강의실의 수업이 끝나는 시간보다 i번째 수업의 시작시간이 더 늦으니 기존 강의실에 강의 추가가능 (해당 강의실 종료시간을 pop으로 빼주고 아래줄에서 새로운 종료시간 추가해주어 최신화 예정)
    heapq.heappush(rooms, time_list[i][1]) #i번째 수업의 종료시간 추가 (기존의 강의장을 사용할 수 있다면 위에 줄에서 하나를 pop해주고 push하는거니 강의실 수량은 동일한 것, 새로운 강의장이 필요해서 위의 줄에서 pop을 하지 않고 push만 했다면 rooms의 총 수량이 1개 추가됨)

'''
설명용 배열:
시간      rooms 값(종료시간)    1     2     3     4     5     6     7     8     9     10     11     12     13
강의실1                       O     O     O     O     O     O     O     O     O     O      O      O      O
강의실2                       O     O     O     O     O     O     O     O     O     O      O      O      O
강의실3                       O     O     O     O     O     O     O     O     O     O      O      O      O
강의실4                       O     O     O     O     O     O     O     O     O     O      O      O      O
강의실5                       O     O     O     O     O     O     O     O     O     O      O      O      O

rooms = [                    ]
rooms[0] = 

--------------------------------------------------------------------------------------------------------


시간      rooms 값        1     2     3     4     5     6     7     8     9     10     11     12     13
강의실1       9           X     X     X     Z     Z     Z     Z     Z     Z     O      O      O      O
강의실2       11          O     X     X     X     Z     Z     Z     Z     Z     Z      Z      O      O
강의실3       10          O     O     X     X     X     Z     Z     Z     Z     Z      O      O      O
강의실4       12          O     O     O     O     O     O     O     X     X     X      X      X      O
강의실5                   O     O     O     O     O     O     O     O     O     O      O      O      O

rooms = [9, 11, 10, 12]
rooms[0] = 9
'''


print(rooms) #[9, 11, 10, 12]

print(len(rooms)) #모든 강의실 배정 후 최종적으로 rooms에 있는 요소의 개수를 출력(각 요소가 강의실 하나를 의미)