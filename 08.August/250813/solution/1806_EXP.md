## 0. 요약


```vbnet
배열:    5   1   3   5   10   7
인덱스:  0   1   2   3    4    5

Step 1: L=0, R=0 [5]         (합=5)       → R++
Step 2: L=0, R=3 [5 1 3 5]   (합=14)      → R++
Step 3: L=0, R=4 [5 1 3 5 10](합=24)      → ans=5, L++
Step 4: L=1, R=4 [1 3 5 10]  (합=19)      → ans=4, L++
Step 5: L=2, R=4 [3 5 10]    (합=18)      → ans=3, L++
Step 6: L=3, R=4 [5 10]      (합=15)      → ans=2, L++
Step 7: L=4, R=4 [10]        (합=10)      → R++
```


## 1. 문제 조건

* 배열의 모든 원소: 양의 정수
* 목표: 합이 **S 이상**인 가장 짧은 연속 구간 길이 찾기

---

## 2. 포인터와 윈도우 개념

```makefile
배열:    [5,   1,   3,   5,  10,   7]
인덱스:   0    1    2    3    4    5
```

* **L(left)**: 윈도우의 시작 인덱스
* **R(right)**: 윈도우의 끝 인덱스
* **윈도우** = `[L, R]` 범위의 연속 구간

---

## 3. 진행 과정 예시 (S = 15)

### Step 1 — 시작

```makefile
L=0, R=0
윈도우: [5]       합=5 (< 15) → 오른쪽 확장
```

### Step 2 — 확장

```
L=0, R=3
윈도우: [5, 1, 3, 5]   합=14 (< 15) → 계속 확장
```

### Step 3 — 조건 달성

```
L=0, R=4
윈도우: [5, 1, 3, 5, 10]   합=24 (≥ 15)
→ 길이 = 5, ans=5
```

### Step 4 — 왼쪽 축소

```
L=1, R=4
윈도우: [1, 3, 5, 10]   합=19 (≥ 15)
→ 길이 = 4, ans=4

L=2, R=4
윈도우: [3, 5, 10]   합=18 (≥ 15)
→ 길이 = 3, ans=3

L=3, R=4
윈도우: [5, 10]   합=15 (≥ 15)
→ 길이 = 2, ans=2
```

### Step 5 — 더 줄이면 불가능

```
L=4, R=4
윈도우: [10]   합=10 (< 15) → 오른쪽 확장
```

---

## 4. 움직임 요약 (텍스트 흐름)

1. **cur < S** → `R`를 1 증가 (윈도우 확장)
2. **cur ≥ S** → 길이 갱신, `L`을 1 증가 (윈도우 축소)
3. `L`과 `R` 둘 다 **한 번씩만 끝까지 이동** → O(N)

---

## 5. 핵심 포인트

* **투 포인터**: L, R이라는 두 인덱스를 조건에 맞춰 독립적으로 움직인다.
* **슬라이딩 윈도우**: 현재 연속 구간 상태를 유지하면서 한쪽 끝만 갱신해 효율적으로 합을 관리한다.
* 결합하면 “**조건 만족 최소 길이 연속 구간**” 같은 문제를 O(N)에 해결 가능.

---


