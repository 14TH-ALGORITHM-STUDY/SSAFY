# BOJ 16236 — 아기 상어: BFS 요약 노트

## 핵심 포인트
- **BFS 한 번 = 먹을 물고기 1마리 탐색**
  - 최단거리 탐색이므로 BFS가 적합합니다.
  - 후보가 여러 개이면 **거리 → 행(작은) → 열(작은)** 순으로 선택합니다.

## 이동 규칙
- **지나갈 수 있음:** `칸의 물고기 크기 ≤ 상어 크기`
- **먹을 수 있음:** `0 < 칸의 물고기 크기 < 상어 크기`

## 성장 규칙
- 먹은 개수 `eaten == size` 가 되면  
  → `size += 1`, `eaten = 0` 으로 초기화합니다.

## 방문/거리 관리
- `dist`를 **-1(미방문)** 으로 초기화하고, BFS로 거리를 갱신합니다.
- `dist[i][j]` 는 시작점으로부터의 최단 이동 횟수를 의미합니다.

## 가지치기 최적화
- 이미 `best_d`(발견된 **최단 먹이 거리**)가 있으면, 그보다 **먼 칸은 확장만 스킵**하거나
  **큐에 푸시하지 않도록** 하여 탐색량을 줄입니다.

---

```
INPUT N
BOARD[N][N]  // 0: 빈칸, 1~6: 물고기 크기, 9: 아기상어 시작

// 방향: 위, 왼, 오른, 아래  (동률일 때 위→왼쪽 우선과 잘 맞음)
DIRS = [(-1,0), (0,-1), (0,1), (1,0)]

// 시작 위치 찾기
(si, sj) = position where BOARD[i][j] == 9
BOARD[si][sj] = 0   // 시작 칸은 빈칸 처리

size = 2
eaten = 0
total_time = 0

LOOP:
    prey = BFS_FIND_PREY(BOARD, N, si, sj, size)
    IF prey == NONE:
        BREAK
    (ti, tj, dist) = prey

    total_time += dist
    eaten += 1
    BOARD[ti][tj] = 0      // 먹은 칸 비우기
    (si, sj) = (ti, tj)    // 상어 위치 갱신

    IF eaten == size:
        size += 1
        eaten = 0

PRINT total_time


FUNCTION BFS_FIND_PREY(BOARD, N, si, sj, size):
    // dist는 방문/거리 겸용: -1은 미방문
    dist[N][N] = filled with -1
    QUEUE q
    PUSH q, (si, sj)
    dist[si][sj] = 0

    best_d = +INF
    best_pos = (-1, -1)

    WHILE q not empty:
        (i, j) = POP_FRONT(q)

        // 이미 더 좋은 먹이를 찾았다면, 그보다 먼 칸은 굳이 확장할 필요 없음
        IF dist[i][j] > best_d:
            CONTINUE

        FOR each (di, dj) in DIRS:
            ni = i + di
            nj = j + dj
            IF 0 <= ni < N AND 0 <= nj < N AND dist[ni][nj] == -1:
                // 지나갈 수 있는 칸: 상어 크기 이상이면 못 감
                IF BOARD[ni][nj] <= size:
                    dist[ni][nj] = dist[i][j] + 1

                    // 먹을 수 있는 물고기 후보: 0 < 크기 < size
                    IF 0 < BOARD[ni][nj] AND BOARD[ni][nj] < size:
                        d = dist[ni][nj]
                        IF d < best_d:
                            best_d = d
                            best_pos = (ni, nj)
                        ELSE IF d == best_d:
                            // 행이 작은 것, 같으면 열이 작은 것
                            IF (ni < best_pos.i) OR (ni == best_pos.i AND nj < best_pos.j):
                                best_pos = (ni, nj)

                    // 지나갈 수 있는 칸은 계속 탐색
                    PUSH q, (ni, nj)

    IF best_d == +INF:
        RETURN NONE
    ELSE:
        RETURN (best_pos.i, best_pos.j, best_d)
```