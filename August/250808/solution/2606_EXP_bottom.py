# 입력 예시
# 4 7
# 6 13
# 4 8
# 3 6
# 5 12

N, K = map(int, input().split())  
# N=4, K=7

items = [(0, 0)]  # 인덱스 맞추기 위해 0번 아이템 넣음
# items = [(0,0)]

for _ in range(N):
    w, v = map(int, input().split())
    items.append((w, v))
    # 반복1: w=6, v=13 → items = [(0,0), (6,13)]
    # 반복2: w=4, v=8  → items = [(0,0), (6,13), (4,8)]
    # 반복3: w=3, v=6  → items = [(0,0), (6,13), (4,8), (3,6)]
    # 반복4: w=5, v=12 → items = [(0,0), (6,13), (4,8), (3,6), (5,12)]

# dp 테이블 초기화 (N+1 행, K+1 열, 전부 0)
dp = [[0] * (K + 1) for _ in range(N + 1)]
# dp[0] = [0,0,0,0,0,0,0,0]
# dp[1] ~ dp[4]도 동일하게 초기화

# i=1부터 N까지 (각 물건을 하나씩 고려)
for i in range(1, N + 1):  
    # i=1일 때 → 현재 물건: items[1] = (6,13)
    # i=2일 때 → 현재 물건: items[2] = (4,8)
    # i=3일 때 → 현재 물건: items[3] = (3,6)
    # i=4일 때 → 현재 물건: items[4] = (5,12)

    for j in range(1, K + 1):  
        # j=1~7까지 → 현재 배낭의 허용 용량
        
        weight, value = items[i]
        # weight = 현재 물건 무게
        # value  = 현재 물건 가치
        # j와 무관하게, 이 줄은 items[i]에서 두 값을 꺼내옴

        if j < weight:  
            # 현재 용량 j가 물건 무게보다 작으면 → 담을 수 없음
            dp[i][j] = dp[i-1][j]
            # 예) i=1, j=5 → weight=6, j<6 → dp[1][5] = dp[0][5] = 0
        else:
            # 담을 수 있으면
            dp[i][j] = max(
                dp[i-1][j],              # 안 담는 경우
                dp[i-1][j - weight] + value  # 담는 경우
            )
            # 예) i=2, j=5 → weight=4, value=8
            # dp[1][5]=0 (안 담음)
            # dp[1][5-4] + 8 = dp[1][1]+8 = 0+8 = 8
            # → dp[2][5] = max(0, 8) = 8

# 반복이 끝나면 dp 테이블은 다음과 같음:
# dp =
# i\j  0  1  2  3  4  5  6  7
# 0   [0, 0, 0, 0, 0, 0, 0, 0]
# 1   [0, 0, 0, 0, 0, 0,13,13]
# 2   [0, 0, 0, 0, 8, 8,13,13]
# 3   [0, 0, 0, 6, 8, 8,13,14]
# 4   [0, 0, 0, 6, 8,12,13,14]

print(dp[N][K])  
# dp[4][7] = 14 → 최대 가치
